use crate::analyzer;
use crate::parser;
use crate::assembling;
use crate::error::{BlobResult, BlobdlError};
use crate::run;

use directories::ProjectDirs;
use std::fs::{self};
use std::path::PathBuf;
use std::io::Write;

use crate::assembling::youtube;
use crate::parser::ConfigFilePreferences;

/// Calls the builder function according to what the url refers to (video/playlist), then it runs the ytdl-command and handles errors
pub fn dispatch(cli_config: &parser::CliConfig) -> BlobResult<()> {
    // Whether a new config file should be generated
    let mut should_generate_config = false;
    
    // user_config is created with data from the config file. Once execution
    // reaches the point where questions need to be asked to the user, data which is already
    // present in user_config is used instead of being asked the user directly
    let user_config = match cli_config.config_file_preference() {
        // There is no config file
        ConfigFilePreferences::NoConfig => youtube::config::DownloadConfig::empty(),
        // The config file is in blob-dl's default location
        ConfigFilePreferences::DefaultConfig => {
            let path = get_config_path().ok_or(BlobdlError::ConfigFileNotFound)?;
            read_config(&path)?
        }
        ConfigFilePreferences::CustomConfig(custom_path) => read_config(custom_path)?,
        
        ConfigFilePreferences::GenerateConfig => {
            should_generate_config = true;
            youtube::config::DownloadConfig::empty()
        }
    };
    
    // Parse what the url refers to
    let download_option = analyzer::analyze_url(cli_config.url())?;

    // Generate a command according to the user's preferences
    let mut command_and_download_config = assembling::generate_command(cli_config.url(), &download_option, user_config)? ;

    if cli_config.show_command() {
        println!("Command generated by blob-dl: {:?}", command_and_download_config.0);
    }

    if should_generate_config {
        // Currently config-files cannot be generated in an arbitrary location
        if let Some(path) = get_config_path() {
            let mut tmp = command_and_download_config.1.clone();
            tmp.url = None;
            write_config(path, &tmp)?;
        } else {
            eprintln!("blob-dl couldn't create a config file");
        }
    }
    
    // Run the command
    run::run_and_observe(&mut command_and_download_config.0, &command_and_download_config.1, cli_config.verbosity())?;

    Ok(())
}

// Functions to handle config files
/// Get the (default) location of the config file, it depends on what operating system blob-dl is running on
fn get_config_path() -> Option<PathBuf> {
    ProjectDirs::from("", "", "blob-dl")
        .map(|dirs| dirs.config_dir().join("config.json"))
}

/// This will create a new config file (or overwrite an old one) with the DownloadConfig that is passed in.
/// 
/// The path needs to also be passed in because the user could put their config file in an unexpected place and
/// say where it is via a command line argument
fn write_config(path: PathBuf, download_config: &youtube::config::DownloadConfig) -> BlobResult<()> {
    if let Some(parent) = path.parent() {
        // If a config file has never been created, this creates all the necessary directories
        // such as "~/.config/blob-dl/ ..."
        fs::create_dir_all(parent)?;
    }

    let parsed_json = serde_json::to_string_pretty(download_config)?;

    // If the file already exists, all its contents are wiped
    let mut file = fs::File::create(path)?;
    file.write_all(parsed_json.as_bytes())?;

    Ok(())
}

/// Create a DownloadConfig object from the contents of the config file
// TODO Tell the user if this returns None (no config file was found, but blob-dl will still work as normal)
fn read_config(config_file_path: &PathBuf) -> BlobResult<youtube::config::DownloadConfig> {
    let contents = fs::read_to_string(config_file_path)?;
    serde_json::from_str(&contents).map_err(|err| {BlobdlError::SerdeError(err)})
}